# 左神算法训练营笔记



![1616493308345](.\img\1616493308345.png)

> master公式：T(N)=a*T(N/b)+O(N^d)

> T(N)是母问题规模，T(N/b)是子问题规模。这个master公式想说明的就是，对于满足此公式的递归调用，可以直接根据a、b、k三者的值来得出母问题的时间复杂度

## 第一讲、排序

### 1.1 归并排序

保证数组左侧有序，再保证数组右侧有序，再进行整体上的排序，整体的排序 过程借助于一个help数组来实现，左右两侧分别用一个指针进行遍历，同时比较大小，谁小就先把该指针对应的数写入help并将此指针右移一位，直至所有指针都指向尽头。

```c
void process(int *arr,int L,int R)
{
    if(L==R)
        return;
    int mid = L+((R-L)>>1);//左移右移的优先级比算术运算符要低
    process(arr,L,mid); //处理好左边的
    process(arr,mid+1,R); //处理好右边的
    merge(arr,L,mid,R); //整体做一个归并排序
}
void merge(int *arr,int L,int M,int R)
{
    int *help=(int*)malloc(sizeof(int)*(R-L+1));//申请一个与待排序数组等长的help数组
    int i=0;//负责指向help数组
    int p1=L;//负责左侧的遍历
    int p2=M+1;  //负责右侧的遍历
    while(p1<=M&&p2<=R)
    {
        help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++]; //排序过程
    }
    //将剩余的未比较的元素加入help数组
    while(p1<=M)
    {
        help[i++]=arr[p1++];
    }
    while(p2<=R)
    {
        help[i++]=arr[p2++];
    }
    //拷贝回原数组
    for(i=0;i<R-L+1;i++)
    {
        arr[L+i]=help[i];
    }
    
}

```

> 时间复杂度分析，整个过程是符合master公式的，所以可以根据公式算得时间复杂度为O(nlogn)

> 空间复杂度为O(N)

* 例题 1

![1616558370696](C:\Users\SKX\AppData\Roaming\Typora\typora-user-images\1616558370696.png)

```c
int process(int *arr,int l,int r)
{
    if(l==r)return0;
    int mid=l+((r-l)>>1);
    //小和就是等于左侧小和+右侧小和+左右两侧做merge时产生的小和
    return process(arr,l,mid)+process(arr,mid+1,r)+merge(arr,l,m,r);
}
int merge(int *arr,int l,int m,int r)
{
    int *help=(int*)malloc(sizeof(int)*(r-l+1));
    int i=0;
    int p1=L;
    int p2=m+1;
    int res=0;
    while(p1<=m&&p2<=r)
    {
        //用res计算比左侧元素大的个数与左侧元素的乘积
        res+=(arr[p1]<arr[p2])?(r-p2+1)*arr[p1]:0;
        help[i++]=arr[p1]<arr[p2]?arr[p1++]:arr[p2++];
    }
    while(p1<=m)
    {
        help[i++]=arr[p1++];
    }
    while(p2<=r)
    {
        help[i++]=arr[p2++];
    }
    for(i=0;i<r-l+1;i++)
    {
        arr[L+i]=help[i];
    }
    return res;
}
```

* 例题 2

![1616561161026](.\img\1616561161026.png)

### 1.2 快速排序

```c
void Quick_sort(int *nums,int start ,int end)
{
   if(start>=end)return;
   int i=start,j=end;
   int door=nums[start];
   while(i<j)
   {
       while(i<j&&nums[j]>door)
           j--;
       nums[i]=nums[j];
       while(i<j&&nums[i]<=door)
           i++;
       nums[j]=nums[i];
   }
   nums[i]=door;
   Quick_sort(nums,start,i-1);
   Qucik_sort(nums,i+1,end);
}
```

随机选择一个门控位 ，那么快排的时间复杂度为O(nlogn)、空间复杂度为O(logn)

#### 荷兰国旗问题

```c
/*
1)当nums[i]<
*/
void sortcolor(int *nums,int numsSize)
{
    if(numsSize<2)
        return;
    int i=0;
    int j=numsSize;
    int k=0;
    while(k<j)
    {
        if(nums[k]==0)
        {
            swap(nums[i],nums[k]);
            i++;
            k++;
        }
        else if(nums[k]==1)
        {
            k++;
        }
        else
        {
            j--;
            swap(nums[k],nums[j]);
        }
    }
}
```



### 1.3 堆

堆主要分为两类，一类大根堆一类小根堆。大根堆就是根节点是整棵树的最大值，对于他的任意子树，根节点也是最大值。反之如果最小值是根节点，那么就是小根堆。

对于完全二叉树转换成数组，那么根节点与左右子树的一个对应关系如下

**左子树：2*i+1 其中i是根节点的下标**

**右子树：2*i+2 其中是根节点的下标**

**父节点：(i-1)/2  其中i为左右子树的下标**

![1616569504834](.\img\1616569504834.png)

```c

//当有新数据插入大根堆时，如下调整
void heapInsert(int *nums,int index)
{
    while(nums[index]>nums[(index-1)/2])//当前结点值比父节点值大
    {
        swap(nums,index,(index-1)/2);//交换与父类的位置
        index=(index-1)/2;//更改下标
    }
}
//O(logN)
//从大根堆中将最大值弹出并做调整heapify
void heapify(int *nums,int index,int heapsize)
{
    int left=index*2+1;//左孩子的下标
    while(left<heapsize) //下方还有孩子的时候
    {
        //两个孩子中谁的值大就把下标给largest
        int largest = (left+1<heapsize)&&(nums[left+1]>nums[left])?(left+1):left;
        //父和子之间，谁的值大，把下标给largest
        largest = nums[largest]>nums[index]?largest:index;
        //如果父节点还是大一些就跳出调整
        if(largest==index)
        {
            break;
        }
        swap(nums,largest,index);//交换父节点与最大子节点的值
        index=largest;//将交换了的索引给到index，然后循环做这个过程
        left=index*2+1;//左孩子的下标
    }
}
//O(logN)
```

#### Python中的heapq

heapq中只有实现小根堆的方法，没有实现大根堆的方法，所以如果需要实现大根堆需要自己实现，先记住几个常用的方法：

* heapq.heapify()   #创建小根堆
* heapq.heappop()  #从小根堆中弹出堆顶元素
* heapq.heappush() #往小根堆中插入元素

````python
import heapq
#导入需要的包heapq

#首先需要一个list
nums = [1,2,5,6,5,6,8,-9,12,-89,45]
heapq.heapify(nums)  #通过heapify方法将上述的list转换成堆结构
print(nums)#[-89, -9, 5, 1, 2, 6, 8, 6, 12, 5, 45]
node = heapq.heappop(nums)#从堆中弹出最小值
print(node)# -89
heapq.heappush(nums,56) #向堆中加入元素56
print(nums) #[-9, 1, 5, 6, 2, 6, 8, 45, 12, 5, 56]
````

#### Python利用heapq实现优先级队列

通过下列类就可以实现大根堆或其余优先级队列

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.queue = []
        self.index =0
    def push(self,priority,item):
        heapq.heappush(self.queue,(-priority,self.index,item))
        #这里说明一下为什么要用-priority，根据heapq只能生成小根堆的特性，所以我们将优先级大的加一个负号
        #另外，为什么需要引入index这个参数，因为在处理优先级时，我们会遇到两个数据的优先级一样，那么我们就需要根据插入的先后顺序进行处理
        self.index+=1
    def pop(self):
        return (heapq.heappop(self.queue)[-1])  #弹出数据的最后一项即为所需数据
```



### 1.4堆排序（O(nlogn) O(1)）

清楚整个堆的操作以后，堆排序写起来就比较简单了

```c
void heapsort(int *nums)
{
    if(nums==NULL || len(nums)<2)
        return;
    //这里也可以通过从后往前做heapify操作
    for(int i=0;i<len(nums);i++)
    {
        heapInsert(nums,i);//构建大根堆 时间复杂度O(logN)
    }
    int heapsize = len(nums);
    swap(nums,0,--heapsize);//建立好大根堆以后将nums首位元素(也是最大元素)与末尾元素交换
    while(heapsize>0)
    {
        heapify(nums,0,heapsize);//重新调整大根堆
        swap(nums,0,--heapsize);//调整完成之后，在将nums首位元素(也是最大元素)与末尾元素交换
    }
    
}
```

![1616591912476](.\img\1616591912476.png)

假设K=6，**那么我们可以遍历前7个数(下标从0到6)，以这7个数做一个小根堆，那么，原数组的第一个位置的值排完序之后一定是这7个数的最小值**，因为如果是在后面的数，那么这个移动的距离就超过了K。

所以这个题目就是，以K为单位建立小根堆，然后依次将最小值弹出到小根堆的首位，再把后面的数加入小根堆，始终保持小根堆的大小为K

```c

void sort(int *nums,int K)//假设heap为创建好的堆结构
{
    int index=0;
	for(;index<=min(len(nums),K);index++)
    {
        heap.add(nums[index]);  //将nums中的前k个元素加入小根堆
    }
    int i=0;
    for(;index<len(nums);i++,index++)
    {
        heap.add(nums[index]);//逐个将后面的元素加入
        nums[i]=heap.poll()  //同时也逐个弹出最小元素
    }
    while(!heap.isEmpty())
    {
        nums[i++]=heap.poll(); //弹出堆中剩余元素
    }
}

```

### 1.5 桶排序

* 计数排序
* 基数排序

![1616656013743](.\img\1616656013743.png)

### 1.6 比较器

1、在讲解比较器之前我们先来看看sorted函数

> 说明一点：sort是应用在list上的方法，而sorted可以对所有的可迭代对象进行排序
>
> list的sort方法是对已经存在的列表进行操作，无返回值，而内建函数sorted方法返回的是一个新的list，而不是在原理的基础上进行操作

```python
sorted(iterable, cmp=None, key=None, reverse=False)
'''
参数说明：

* iterable -- 可迭代对象。
* cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，          小于则返回-1，等于则返回0。默认的是小的在前
* key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的          一个元素来进行排序。
* reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。
'''
```

用法：

```python
L=[('b',2),('a',1),('c',3),('d',4)]
L1=sorted(L, cmp=lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数
print(L1) #[('a', 1), ('b', 2), ('c', 3), ('d', 4)]

L2 = sorted(L, key=lambda x:x[1])               # 利用key
print(L2) #[('a', 1), ('b', 2), ('c', 3), ('d', 4)]

#无论是key还是cmp都可以使用lambda函数来比较，当然你也可以通过functools库中的cmp_to_key

```



2、python中匿名lambda函数的用法

---

lambda与def的区别：
1）**def创建的方法是有名称的，而lambda没有。**
2）**lambda会返回一个函数对象，但这个对象不会赋给一个标识符，而def则会把函数对象赋值给一个变量（函数名）。**
3）**lambda只是一个表达式，而def则是一个语句。**
4）**lambda表达式” : “后面，只能有一个表达式，def则可以有多个。**
5）**像if或for或print等语句不能用于lambda中，def可以。**
6）**lambda一般用来定义简单的函数，而def可以定义复杂的函数。**
6）**lambda函数不能共享给别的程序调用，def可以。**
lambda语法格式：
lambda 变量 : 要执行的语句

------------------------------------------------
```python
#单一参数
g = lambda x : x ** 2 #x作为lambda函数的参数，函数体就为x^2
print(g(3)) #输出为9
#多个参数
g = lambda x, y, z : (x + y) ** z
print(g(1,2,2))
#9
```



3、自定义比较器

首先我们假设有这样一组数据，二维空间中有3个点，需要 对他们进行排序，规则是先按x坐标排序，如果相同，则按y坐标排序

```python
class Pos:
    def __init__(self,x=0,y=0):
        self.x = x
        self.y = y
    def __str__(self):
        return ('(%s, %s)' % (self.x, self.y))
l = [Pos(5, 1), Pos(2,5), Pos(2, 4)]  #待排序的三个坐标
```

##### 方法1 自定义比较

>  可以通过修改 `key=` 参数，使用 `lambda` 将输入的元素映射成一个值，这个值就代表了这个元素的大小。 
>
> 而这个值呢会根据x，y的比较优先级分配不同的权值，比如我们可以将每个坐标映射成1000*x + y(y不超过1000)

```python
l1 = sorted(l, key=lambda t : 1000 * t.x + t.y)
print_list(l1) #(2, 4),(2, 5),(5, 1)
```

##### 方法2  自定义比较方法

当然我们也可以通过自建比较方法来进对比

```python
from functools import cmp_to_key
#记清楚这个库和对应的方法
def cmp(t1, t2):
    """
    比较函数，需要满足：t1>t2则返回正数，t1=t0则返回0，t1<t2则返回负数。
    cmp默认的是小的在前
    """
    if t1.x == t2.x:
        return t1.y - t2.y
    return t1.x - t2.x

# 新建cmp函数    
l2 = sorted(l, key=cmp_to_key(cmp))
print_list(l2)#(2, 4),(2, 5),(5, 1)
```

#### 1.7 比较字典

1、使用key的方式

```python
#按key进行排序
dict_str = {1:5,2:56,3:89,4:5,6:78,0:78}
dict_str = sorted(dict_str.items(),key=lambda kv:(kv[0], kv[1]))
print(dict_str) #[(0, 78), (1, 5), (2, 56), (3, 89), (4, 5), (6, 78)] 注意这里的输出是list

#按value
dict_str = {1:5,2:56,3:89,4:5,6:78,0:78}
dict_str = sorted(dict_str.items(),key=lambda kv:(kv[1], kv[0]))
print(dict_str) #[(1, 5), (4, 5), (2, 56), (0, 78), (6, 78), (3, 89)] 注意这里的输出是list
```

2、使用functools 中的cmp_to_key,再自定义一个cmp函数

```python
from functools import cmp_to_key
dict_str = {1:5,2:56,3:89,4:5,6:78,0:78}
def cmp(t1,t2):
    if t1[1]==t2[1]:
        return t1[0]-t2[0]
    return t1[1]-t2[1]
dict_str = sorted(dict_str.items(),key=cmp_to_key(cmp))
print(dict_str) #[(1, 5), (4, 5), (2, 56), (0, 78), (6, 78), (3, 89)]
```

## 第二讲、链表

* 例题1

![1616659275410](.\img\1616659275410.png)

```python
思路：用两个指针分别指向A链表和B链表，然后谁小谁移动，然后相等就打印出来，两个指针共同移动。
```

### 思路技巧

![1616659453123](.\img\1616659453123.png)

### 例题

* 题目1

![1616659615062](.\img\1616659615062.png)

1、笔试解法：

**直接用个栈**，空间大小优化就是看你是放整个链表，还是只放右侧链表

2、面试解法(写熟)

```C
void IsPalindrom(ListNode *head)
{
    if(head ==NULL || head->next==NULL)
        return true;
    ListNode *n1=head;
    ListNode *n2=head;
    //以下这种快慢指针的写法要记住
    while(n2->next!=NULL&&n2->next->next!=NULL)//find mid node
    {
        n1=n1->next;  //mid
        n2=n2->next->next;  //end
    }
    n2=n1->next; //n2指向右侧第一个结点
    n1->next=NULL;//中间结点的next指针置空
    ListNode n3=NULL;
    //反转链表，这段代码也是写的极好
    while(n2!=NULL)
    {
        n3=n2->next; //保存下一个结点
        n2->next=n1;  //让n2指向前一个结点，完成反转
        n1=n2;    //依次挨个做些去
        n2=n3;
    }
    n3=n1; //n3保存最后一个结点
    n2=head; //n2指向头结点，此时后半段的链表已经反转完毕
    bool res=true;
    while(n1!=NULL&&n2!=NULL)
    {
        if(n1->value!=n2->value)  //检查两侧的值是否一一对应
        {
            res=false;
            break;
        }
        n1=n1->next;
        n2=n2->next;
    }
    //做一次反转复原
    n1=n3->next;
    n3->next=NULL;
    while(n1!=NULL)
    {
        n2=n1->next;
        n1->next=n3;
        n3=n1;
        n1=n2;
    }
    return res;
}
```

* 题目2

![1616662013412](.\img\1616662013412.png)

1、笔试解法：

把单链表的值copy到数组，然后在数组上来一轮partition就行。

```c
int i=0,j=numsSize;
int k=0;
while(k<j)
{
   if(nums[k]>1)
   {
       j--;
       swap(nums,k,j);
   }
   else if(nums[k]<1)
   {
       swap(nums[k],nums[i]);
       i++;
       k++;
   }
   else
       k++;
}
```

2、面试解法

用6个变量，分别表示小于pivot的头结点和尾结点、等于pivot的头结点和尾结点、大于pivot的头结点和尾节点

```c
Listnode *listPartition(Listnode *head,int pivot)
{
    Listnode *sH=NULL;//小于的头
    Listnode *sT=NULL;//小于的尾
    Listnode *eH=NULL;//等于的头
    Listnode *eT=NULL;//等于的尾
    Listnode *mH=NULL;//大于的头
    Listnode *mT=NULL;//大于的尾
    while(head!=NULL)
    {
        next=head->next;
        head->next=NULL;
        if(head->value<pivot)  //小于区域
        {
            if(sH==NULL)  //还没有结点
            {
                sH=head;
                sT=head;
            }
            else   //有结点了
            {
                sT->next=head;
                sT=head;
            }
        }
        else if(head->value==pivot)  //等于区域
        {
            if(eH==NULL)   //还没有结点
            {
                eH=head;
                eT=head;
            }
            else   //有结点了
            {
                eT->next=head;
                eT=head;
            }
        }
        else  //大于区域
        {
            if(mH==NULL)  //还没有结点
            {
                mH=head;
                mT=head;
            }
            else     //有结点了
            { 
                mT->next=head;
                mT=head;
            }
        }
    }
    //边界问题，如果没有小于区域，或者没有等于区域，连接问题
    if(sT!=NULL)  //如果有小于区域
    {
        sT->next=eH;
        eT=eT==NULL?sT:eT; //谁去连大于区域的头，谁就变成eT
    }
    if(eT!=NULL)  
    {
        eT->next=mH;  //连接操作
    }
    return sH!=NULL?sH:(eH!=NULL?eH:mH);
}
```

* 题目3

![1616676042378](.\img\1616676042378.png)

![1616677059742](.\img\1616677059742.png)

 

* 题目4

![1616677536137](.\img\1616677536137.png)

```
对于有环链表，我们利用快慢指针，同时从链表的head结点出发，快指针一次走两步，慢指针一次走一步。如果链表有环，那么在环上一定两指针会相遇，第一次相遇后，让其中一个指针回到head结点，另一个留着相遇结点处，再让两个指针都同时以每次走一步的速度出发，那么相遇的位置就是第一个入环结点。
```

![1616679293867](.\img\1616679293867.png)

```c
ListNode getLoopNode(ListNode *head)
{
   if(head==NULL||head->next==NULL||head->next->next==NULL)
        return NULL;
    ListNode * n1=head->next;
    ListNode * n2=head->nxt->next;
    while(n1!=n2)
    {
        if(n2->next==NULL||n2->next->next==NULL)
        {
            return NULL;
        }
        n2=n2->next->next;
        n1=n1->next;
    }
    n2=head;  //将其中一个结点置到head
    while(n1!=n2)
    {
        n1=n1->next;
        n2=n2->next;
    }
    return n1;  //再次相遇的位置即为第一个入环结点

}
```

根据上述我们可以分析

1）假设两个链表都为没有环，这个题就比较简单，这个直接先得出两个链表的长度，**然后让长的那个链表的指针先走(长度差)步，然后两个链表再同时走，直到两个链表相等**。

![1616766405467](.\img\1616766405467.png)

2）假设两个链表有一个有环，而另一个无环   ------>不可能相交

3）两个链表 都有环

* 两个链表各自为环
* 两个链表共用一个环，但是在入环之前就相交了
* 两个链表共用一个环，但是在环上相交

![1616767167798](.\img\1616767167798.png)

如上图所示，三种情况，那么第二种是好判断的，我们根据上述的getLoopNode函数先得到两个链表的第一个入环结点：

* 如果两个入环结点相等，说明是第二种情况，那么直接以这个结点为终结点，来找第一个入环结点，问题就转化成了两个链表无环相交问题
* 如果两个入环结点不相等，那么让其中一个结点先走一圈，再回到自己之前如果遇到了另一个结点，就说明是情况三，那么返回两个结点中任何一个都可以；如果没遇到另一个结点，就说明没有相交，就是第一种情况，则返回空

## 第三讲 二叉树

### 3.1 二叉树的遍历

* 二叉树的先序遍历

```c
//递归方式
void preOrderTree(Node head)
{
   if(head!=NULL)
   {
       process(head);
       preOrderTree(head->left);
       preOrderTree(head->right);
   }
}
//非递归方式
void preOrderTree(Node root)
{
   if(head!=NULL)
   {
        stack=new LinkedList; //新建一个栈
        stack.push(head);//将结点进栈
       while(!stack.isEmpty())
       {
           head=stack.pop();
           process(head);//处理结点
           //先进右结点
           if(head.right!=NULL)
           {
               stack.push(head.right);
           }
           //再进左节点
           if(head.left!=NULL)
           {
               stack.push(head.left);
           }
       }
       
   }
}
```

* 二叉树的中序遍历

```c
//递归方式
void inOrderTree(Node head)
{
   if(head!=NULL)
   {
       inOrderTree(head->left);
       process(head);
       inOrderTree(head->right);
   }
}
//非递归方式
void inOrderTree(Node head)
{
    if(head!=NULL)
    {
        stack=new LinkedList; //新建一个栈
        while(!stack.isEmpty()||head!=NULL)
        {
            if(head!=NULL)
            {
                stack.push(head);//将结点进栈
                head=head.left;  //移动到左结点
            }
            else
            {
                head = stack.pop(); //出栈
                process(head);//处理结点
                head=head.right;
            }
        }
    }
}
```

* 二叉树的后序遍历

```c
//递归方式
void postOrderTree(Node head)
{
   if(head!=NULL)
   {
       postOrderTree(head->left);
       postOrderTree(head->right);
       process(head);
   }
}
//非递归方式
//后序遍历的非递归方式是可以通过先序遍历的递归方式进行调整的
//在先序遍历中，我们访问了根节点以后先进了右孩子之后再进左孩子  -->根左右
//那么在这时，如果我们先进左孩子，后进右结点，这时    -->根右左
//那么此时，我们不直接以这种方式遍历，而是先进一个收集栈之后在遍历，那是不是就是一个逆序过程了-->左右根
//就变成了后序遍历
void postOrderTree(Node head)
{
    
}
```

* 层次遍历

用个队列就行，这个写的比较熟，就不多赘述，但是有个额外的附加问题这里说一下,我希望在层次遍历的时候也能知道当前节点是第几层的。

使用哈希表的方法

```c
void levelOrder(Node head)
{
    if(head=NULL)
        return;
    Queue queue=new Lin****;//定义一个队列
    queue.add(head);//将根节点进队列
    /*记录节点在第几层的hashmap*/
    HashMap levelMap;
    levelMap.put(head,1);
    int curlevel=1;  //当前层数
    int curlevelnodes = 0; //当前层数的结点个数
    int max_ = Integer.MIN_VALUE;//系统最小值 记录结点最多的层的结点数
    
    while(!queue.isEmpty())
    {
        Node cur = queue.pop();//出队列
        int curnodelevel = levelMap.get(cur);//获取当前节点的层数
        if(curnodelevel==curlevel)
        {
            curlevelnodes++; //与当前层数相等，那么就将结点数++
        }
        else //到了下一层了
        {
            max_=max(max_,curlevelnodes);
            curlevel++;//当前层数+1
            curlevelnodes=1; //结点个数置1
        }
        if(cur.left!=NULL)
        {
            levelMap.put(cur.left,curnodelevel+1); //将左孩子加入hash表，其中层数为当前层+1
            queue.add(cur.left);//将左孩子节点进队列
        }
        if(cur.right!=NULL)
        {
            levelMap.put(cur.right,curnodelevel+1); //将右孩子加入hash表，其中层数为当前层+1
            queue.add(cur.right);//将右孩子节点进队列
        }
    }
}
```

#### 题目

* 判断一棵二叉树是否是搜索二叉树(二叉排序树、二叉查找树)

二叉排序树：  若它的左子树不空，则左子树上所有结点的值均小于它的**根结点**的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为**二叉排序树**。

二叉排序树的中序遍历序列为有序序列。所以我们可以直接中序遍历一下一棵二叉树，如果一直在升序，那么是；否则就不是。

```c
int prevalue=Integer.MIN_VALUE;
bool inOrderBST(Node head)
{
   if(head==NULL)
   {
       return true;
   }
   bool isleftbst=inOrderTree(head->left); //判读左子树是否为二叉搜索树
    
   if(!isleftbst)
       return false;
   if(head.value<=prevalue)   //判断当前值是否比前一个要大
       return false;
    else
        prevalue=head.value;
    
   return inOrderTree(head->right);
}
```

* 判断一棵树是否是完全二叉树

用层次遍历的方式，进行如下判断

1)任一结点，有右孩子但无左孩子返回False

2)在不违反1的情况下，如果遇到了第一个左右孩子不双全的结点，那么后续结点均为叶子结点，否则返回False 

```c
bool isCBT(Node head)
{
    if(head==null)
        return true;
    Queue queue=new Lin****;//定义一个队列
    bool leaf = false;//标志位，从此时开始之后的结点都应该是叶节点
    Node l=NULL;
    Node r=NULL;
    queue.add(head);//将根节点进队列
    while(!queue.isEmpty())
    {
        head=queue.pop();
        l=head.left;
        r=head.right;
        //两个条件
        if((leaf&&(l!=NULL || r!=NULL))  
            ||
            (l==NULL && r!=NULL))
            return false;
        
        if(l!=NULL)
            queue.add(l);
        if(r!=NULL)
            queue.add(r);
        if(l==NULL || r ==NULL)  //两个孩子不双全  我认为只需要判断r是否为空即可
            leaf=true;
    }
    return true;
    
}
/****
|l      | r        |     |
|NULL   | NULL     |True |
|!NULL  | NULL     |True |
|NULL   | !NULL    |直接返回了false |
|!NULL  | !NULL    |False |
所以通过这种情况可以知道只有当r==NULL的时候才将leaf置为True
***/
```

* 判断一个数是否是平衡二叉树（左右子树高度差小于等于1）

```c
//定义一种返回类型，包含我需要左子树和右子树提供的信息类型
struct ReturnType{
    bool isB; //是否是平衡二叉树
    int height; //高度
};
//主函数
bool isBalanced(Node head)
{
    return process(head).isB;
}
//递归函数
struct ReturnType process(Node x)
{
    struct ReturnType res;
    //递归的basecase
    if(x==NULL)
    {
        res.isB=true;
        res.height=0;
    }
    struct ReturnType leftData=process(x.left);  //获取左树的信息
    struct ReturnType leftData=process(x.right);  //获取右树的信息
    
    int height = max(leftData.height,rightData.height)+1;  //树的高度
    bool isBalanced = leftData.isB && rightData.isB && abs(leftData.height-rightData.height)<2;  //要同时满足左树为平衡树，右树为平衡树，且左右两树的高度差小于2，就满足此树为平衡树
    
    res.isB=isBalanced;
    res.height=height;
    return res;
}
```

以上的递归套路：

* 首先我们需要先分析为了求解这个问题，我们需要哪些信息(左子树，右子树)
* 有了信息之后，我们定义一种结构体同时包含这些信息
* 用后序的形式，假设我们已经得到了左右子树给的信息，写出根节点处需要的操作并做一个返回
* 别忘了加递归的basecase

**用以上套路求解一下，判断一个树是否为搜索二叉树：**

要判断是否为搜索二叉树，那么我们就需要从左右子树中的 得到如下信息：

1：左、右子树是否为搜索二叉树

2：左子树的最大值要小于根节点

3：右子树的最小 值要大于根节点

```c
//定义一种返回类型，包含我需要左子树和右子树提供的信息类型
struct ReturnType{
    bool isSort; //是否是搜索二叉树
    int min_value; //最小值
    int max_value; //最大值
};
struct ReturnType process(Node x)
{
     struct ReturnType res;
    //递归的basecase
    if(x==NULL)
    {
        return NULL;
    }
    struct ReturnType leftData=process(x.left);  //获取左树的信息
    struct ReturnType leftData=process(x.right);  //获取右树的信息
    
    //以下确认整棵树的最小最大值
    int min=x.value;
    int max=x.value;
    if(leftData!=NULL)
    {
        min = min(min,leftData.min_value);
        max = max(max,leftData.max_value);
    }
    if(rightData!=NULL)
    {
        min = min(min,rightData.min_value);
        max = max(max,rightData.max_value);
    }
    bool isSort=true;
    if(leftData!=NULL&&(!leftData.isSort ||leftData.max_value>=x.value))
    {
        isSort=false;
    }
    if(rightData!=NULL&&(!rightData.isSort ||rightData.min_value<=x.value))
    {
        isSort=false;
    }
    
    res.isSort=isSort;
    res.min_value=min;
    res.max_value=max;
    
    return res;
}
```

### 3.2 树形DP问题

先看一个题目

![1617885419252](.\img\1617885419252.png)

```c
/**********************
整个思路分为两种情况：
1、根节点不参与：结果就是max(左子树最大距离，右子树最大距离)
2、根节点参与 ：结果就是左子树的高度+右子树的高度+1
**********************/
typedef struct Info{
    int maxDistance;
    int height;
}Info;
Info *process(Node x)
{
    Info *res = (Info*)malloc(sizeof(Info));
    if(x==NULL)
    {
        res->maxDistance=0;
        res->height=0;
        return res;
    }
    //用黑盒的过程
    Info *leftInfo = process(x.left);  
    Info *rightInfo = process(x.right);
    
    //用完黑盒还能在函数将黑盒实现
    int p1 = leftInfo->maxDistance;//左子树的最大距离
    int p2 = rightInfo->maxDistance; //右子树的最大距离
    int p3 = leftInfo->height + 1 + rightInfo->height;  //左子树高度 + 1 右子树高度
    int maxDistance=max(p3,max(p1,p2));   //三者的最大值
    int height = max(leftInfo->height,rightInfo->height)+1;  //树的高度
    
    res->maxDistance = maxDistance;
    res->height = height;
    return res;
}

```

![1618056831988](.\img\1618056831988.png)

* 题目二

![1618056873411](.\img\1618056873411.png)

````c
/************************
假设根节点为x，他有三个孩子节点分别是a、b、c
可能性：
1、根节点x参与
返回值就是：x的快乐值 + a不参与的最大快乐值 + b不参与的最大快乐值 + c不参与的最大快乐值
2、x不参与
返回值为：0 + max(a参加的最大值，a不参加的最大值) + max(b参加的最大值，b不参加的最大值)+max(c参加的最大值，c不参加的最大值)

所以需要找子树要什么信息？要他根节点来的最大值，和他不来的最大值
************************/
typedef struct Info{
    int max_value_with;  //来的最大欢乐值
    int max_value_without;  //不来的最大欢乐值
}Info;
Info *process(Node x)
{
    Info * res=(res*)malloc(sizeof(Info));
    if(x.nexts==NULL)  //当结点的孩子都为空时，就是基础员工
    {
        res.max_value_with = x.max_value_with;
        res.max_value_withot = x.max_value_without;
    }
    int max_value_with =x.max_value_with;  //来
    int max_value_without = 0;      //不来
    for node in x.nexts   //挨个处理结点的每个子孩子
    {
        Info nextInfo = process(node);  //处理一下当前的孩子节点
        max_value_with+=nextInfo.max_value_withot;  //父节点来 然后挨个加上子子节点不来
        max_value_without += max(nextInfo.max_value_with,node.max_value_without);
        //当前结点不来，则加上所有结点来或者不来的最好情况
    }
    
    res->max_value_with = max_value_with;
    res->max_value_without = max_value_without;
    return res;
}
int main()
{
    Info res=process(root);
    return max(res.max_value_with,re.max_value_without);
}
````

### 3.3 Morris遍历

![1618060496975](.\img\1618060496975.png)

![1618060519196](.\img\1618060519196.png)

```c
void morris(Node head)
{
   if(head==NULL)
       return NULL;
    Node cur = head; //当前节点
    Node mostRight = NULL;  //左树上的最右结点
    while(cur!=NULL)
    {
        mostRight = cur.left; //mostRight是cur的左孩子
        if(mostRight!=NULL)  //有左树
        {
            //找到左树上的最右结点
            while(mostRight.right!=NULL && mostRight.right!=cur)
            {
                mostRight = mostRight.right;
            }
            //退出循环只有两种情况1、mostRight的右结点为空 2、mostRight的右结点为cur
            
            //如果mostRight.right为空，说明第一次来到cur
            if(mostRight.right==NULL)
            {
                mostRight.right = cur;
                cur=cur.left;
                continue;
            }
            else
            {
                //否者就是第二次来到cur,就将mostRight.right还原为NULL
                mostRight.right=NULL;
            }
        }
        //如果没有子树，或者处理完左子树，就转向右结点
        cur = cur.right;
    }
}
```

Morris是遍历有这样的特征:一个结点只要他有左子树，那么遍历过程中就会来到这个结点两次。那么我们就可以通过这样的一个特性来进行处理，进而将Morris遍历改变成先序后序等遍历方式。

* **Morris遍历实现先序遍历**：对于有左子树的结点，只当第一次来到这个结点的时候打印，第二次跳过不管；对于没有左子树的结点是直接打印就行。

```c
void morris(Node head)
{
   if(head==NULL)
       return NULL;
    Node cur = head; //当前节点
    Node mostRight = NULL;  //左树上的最右结点
    while(cur!=NULL)
    {
        mostRight = cur.left; //mostRight是cur的左孩子
        if(mostRight!=NULL)  //有左树
        {
            //找到左树上的最右结点
            while(mostRight.right!=NULL && mostRight.right!=cur)
            {
                mostRight = mostRight.right;
            }
            //退出循环只有两种情况1、mostRight的右结点为空 2、mostRight的右结点为cur
            
            //如果mostRight.right为空，说明第一次来到cur
            if(mostRight.right==NULL)
            {
                print(cur.value);   //第一次到达这个结点就直接打印即可
                mostRight.right = cur;
                cur=cur.left;
                continue;
            }
            else
            {
                //否者就是第二次来到cur,就将mostRight.right还原为NULL
                mostRight.right=NULL;
            }
        }
        else
        {
            print(cur.value);   //对于没有左子树的结点直接打印即可
        }
        //如果没有子树，或者处理完左子树，就转向右结点
        cur = cur.right;
    }
}
```

* **Morris遍历实现中序遍历**：对于有左子树的结点，只当第二次来到这个结点的时候打印，第一次跳过不管；对于没有左子树的结点是直接打印就行。

```c
void morris(Node head)
{
   if(head==NULL)
       return NULL;
    Node cur = head; //当前节点
    Node mostRight = NULL;  //左树上的最右结点
    while(cur!=NULL)
    {
        mostRight = cur.left; //mostRight是cur的左孩子
        if(mostRight!=NULL)  //有左树
        {
            //找到左树上的最右结点
            while(mostRight.right!=NULL && mostRight.right!=cur)
            {
                mostRight = mostRight.right;
            }
            //退出循环只有两种情况1、mostRight的右结点为空 2、mostRight的右结点为cur
            
            //如果mostRight.right为空，说明第一次来到cur
            if(mostRight.right==NULL)
            {
                mostRight.right = cur;
                cur=cur.left;
                continue;
            }
            else
            {
                //否者就是第二次来到cur,就将mostRight.right还原为NULL
                print(cur.value);   //第二次到达这个结点就直接打印即可
                mostRight.right=NULL;
            }
        }
        else
        {
            print(cur.value);   //对于没有左子树的结点直接打印即可
        }
        //如果没有子树，或者处理完左子树，就转向右结点
        cur = cur.right;
    }
}
```

* **Morris遍历实现后序遍历**：对于能到两次的结点，第一次到达时什么也不做，第二次到达时再逆序打印其左子树上的右边界；最后在逆序打印一下整棵树的右边界。

关于怎么逆序打印右边界就是单链表的逆序操作，要实现时间复杂度O(N),空间复杂度O(1)，注意看链表那一节的判断回文链表。

```c
void morris(Node head)
{
   if(head==NULL)
       return NULL;
    Node cur = head; //当前节点
    Node mostRight = NULL;  //左树上的最右结点
    while(cur!=NULL)
    {
        mostRight = cur.left; //mostRight是cur的左孩子
        if(mostRight!=NULL)  //有左树
        {
            //找到左树上的最右结点
            while(mostRight.right!=NULL && mostRight.right!=cur)
            {
                mostRight = mostRight.right;
            }
            //退出循环只有两种情况1、mostRight的右结点为空 2、mostRight的右结点为cur
            
            //如果mostRight.right为空，说明第一次来到cur
            if(mostRight.right==NULL)
            {
                mostRight.right = cur;
                cur=cur.left;
                continue;
            }
            else
            {
                //否者就是第二次来到cur,就将mostRight.right还原为NULL
                printEdge(cur.left);   //第二次到达这个结点就直接打印即可
                mostRight.right=NULL;
            }
        }
        //如果没有子树，或者处理完左子树，就转向右结点
        cur = cur.right;
    }
    printEdge(head);
}
```











## 第四讲   图

图的数据结构实现，一般是有邻接表或者邻接矩阵的方式实现的，但是由于一般的题目给的并非理想的这两种方式，所以需要对所给图的结构进行一个转换，转换成熟悉的结构，在 进行后续的一些算法。

```python
#图
class Graph:
    def __init__(self):
        # nodes = {int :Node}
        self.nodes={}
        self.edges = set()
#边集
class Edge:
    def __init__(self,weight=None,from_node=None,to_node=None):
        self.weight=weight
        self.from_node = from_node
        self.to_node = to_node
#点集
class Node:
    def __init__(self,value):
        '''
        value->编号
        in->入度
        out->出度
        '''
        self.value = value
        self.indu = 0
        self.outdu = 0
        self.nexts = []
        self.edges = []
#这种结构包含了所有题目可能出现的图的结构，但是有的时候具体的题目并不需要那么多，比如说对于只是简单利用图这种结构，而不去管两个结点直接边的权重，那么就不需要管edge
```

### BFS

```python
def bfs(node):
    if node==None:
        return 
    queue = []  #广度优先用队列
    hashset = set()   #set用作访问记录
    queue.append(node)
    hashset.add(node)
    while queue!=[]:
        cur_node = queue.pop(0)
        print(cur_node.value)
        for next in cur_node.nexts:
            #如果next_node不在哈希集合结构中，就将该结点加入集合中
            if next_node not in hashset:
                hashset.add(next_node)
                queue.append(next_node)
                #访问该结点
```

### DFS

```python
def dfs(node):
    if node==None:
        return
    stack = []  #深度优先遍历用栈实现
    hashset = set()  #同样也用一个集合结构来记录是否访问
    stack.append(node)
    set.add(node)
    #访问该结点
    while stack!=[]:
        cur_node = stack.pop()
        for next in cur_node.nexts:
            if next not in hashset:
                stack.append(cur_node)
                stack.append(next)
                set.add(next)
                #访问该结点
                break
```

### 拓扑排序

```python
#假设图graph的结构为{编号i:对应的结点node}
def TopoSort(graph):
    if graph==None:
        return
    inMap={}  #用一个哈希表记录每个结点的入度
    zeroInqueue = []  #只有入度为0的结点才能进
    for node in graph.values():
        inMap[node]=node.indu
        if node.indu==0:
            zeroInqueue.append(node) #如果某个点入度为0，就将其加入队列中
    #结果列表，存放拓扑排序的结果
    res=[]
    while zeroInqueue!=[]:
        cur_node = zeroInqueue.pop(0)
        res.append(cur_node)
        for next_node in cur_node.nexts:
            inMap[next_node]-=1
            if inMap[next_node]==0:
                zeroInqueue.append(next_node)
   return res
```

## 第五讲 贪心算法

![1617171802027](.\img\1617171802027.png)

哪个会议结束时间早，就先安排，就能得到最优解。

```c
struct Program{
    int start;
    int end;
};
int bestArrange(Program *programs,int timePoint)  //用一个变量timePoint来记录当前时间节点
{
    //先根据每个项目结束的时间排个序，按结束时间从小到大排序
    int result = 0;
    for(int i=0;i<len(programs);i++)
    {
        if(timePonit<=programs[i].start)  //如果时间节点小于项目i的开始时间
        {
            result++;
            timePoint = programs[i].end; //将时间节点改为项目i的结束时间
            
        }
    }
    return result;
    
}
```

![1617174455969](.\img\1617174455969.png)

### 例题1

![1617196974076](.\img\1617196974076.png)

经典的哈夫曼编码问题，这个问题的解法就是建立一个小根堆，然后把这一串数组都加入到小根堆里面去,然后在进行后续操作

```c
int lessMoney(int *nums)
{
    //创建一个小根堆
    for(int i=0;i<len(nums);i++)
    {
        //将元素加入小根堆
    }
    int sum=0;
    int cur=0;
    while 堆不为空
    {
        cur = 出两个堆元素求和;
        sum+cur;
        把cur加入到小根堆里面去;
    }
    return sum;
}
```

### 例题2

![1617261228117](.\img\1617261228117.png)

用两个堆进行处理，初始时将所有项目按花费值加入小根堆，之后将小于当前拥有资金的项目全部出堆，并进大根堆(按利润值进大根堆)，然后再从大根堆里面出一个利润最大的即可。往返整个过程直到满足k个项目或者满足你的钱不够去做剩下的项目为止。

```c
int findMaximizedCapital(int k,int W,int *Profits,int *Capital)
{
    //创建一个大根堆
    //创建一个小根堆
    //将所有项目都加入到小根堆中去
    for(int i=0;i<len(Profits);i++)
    {
        按花费值将(Profits[i],Capital[i])加入到小根堆中去; 
    }
    for(int i=0;i<k;i++)
    {
        while(小根堆不为空 && 小根堆的堆顶元素小于当前的钱数W)
        {
            将小根堆堆顶出栈;
            然后将此按利润值加入大根堆;  
        }
        if(大根堆为空)
            return W;
        将大根堆出栈;
        W+=P;  //加上利润
    }
    return W;
    
}
```

### 例题3

![1617262808892](.\img\1617262808892.png)

大小根堆相互配合，将第一个数字进大根堆，接下来的数字按如下规则操作：

1) 当前值**小于等于大根堆堆顶**，那么就将当前值加入大根堆，否则就将当前值加入小根堆

2)如果两个堆的尺寸，**较大的那个比较小的大了2**，就将大的那个弹出堆顶进小的堆。

3)这样两个堆的堆顶就可以确定中位数

## 第六讲 暴力递归

![1617265362695](.\img\1617265362695.png)

### 例题

1、

![1617265420974](.\img\1617265420974.png)

![1617266872487](C:\Users\SKX\AppData\Roaming\Typora\typora-user-images\1617266872487.png)

2、

![1617267301573](.\img\1617267301573.png)

```c
void process(char *str,int i,List<Character>res)
{
    if(i==str.length)
    {
        print(res);
        return;
    }
    List<Character>resKeep = copyList(res);  //拷贝一下之前的字符串
    resKeep.add(str[i]); //在末尾添加当前字符
    process(str,i+1,resKeep); //要当前字符的路
    List<Character>resNoInclude = copyList(res);//拷贝一下之前的字符串
    process(str,i+1,resNoInclude); //不要当前的路
}
```

3、

![1617269524772](.\img\1617269524772.png)

![1617269889386](C:\Users\SKX\AppData\Roaming\Typora\typora-user-images\1617269889386.png)

f为先手函数，s为后手函数

4、

![1617270358207](.\img\1617270358207.png)

## 第七讲  并查集

并查集就是一直能同时满足查找和并操作都是线性的特殊数据结构。没有特定的并查集结构，所以并查集结构需要依靠别的数据结构实现。在数据结构教程上是以树的形式实现的，代码如下。

```c
//数据结构
typedef struct node{
    int data;   //结点对应人的编号
    int rank;   //结点对应的秩(近似子树高度的正整数)
    int parent;
    
}UFSTree;
//初始化
void Make_Set(UFSTree *t,int n)
{
    for(int i=1;i<=n;i++)
    {
        t[i].data = i;  //数据为该人的编号
        t[i].rank =0;   //秩初始化为0
        t[i].parent=i;  //双亲初始化指向自己
    }
}
//查找一个元素所属的集合
//在分离集合森林中，每一棵分离集合树对应一个集合。如果要查找某一个元素所属的集合，不妨以分离集合树的根节点的编号来标识这个分离结合树
int Find_Set(UFSTree *t,int x)  //在x所在的子树中查找集合编号
{
    if(x!=t[x].parent)   //双亲不是自己
        return(Find_Set(t,t[x].parent));  //递归寻找
    else
        return (x); //双亲是自己返回x
}

void UNION(UFSTree *t,int x,int y)
{
    x=Find_Set(t,x);  //找两个元素的根节点
    y=Find_Set(t,x);
    
    if(t[x].rank>t[y].rank)  //找到以后如果x对应集合的秩比y的大，就把小的挂到大的上去
        t[y].parent=x;
    else{                    //反之
        t[x].parent=y;
        if(t[x].rank==t[y].rank)  //如果两个相等就将其中一个被挂的那个+1
            t[y].rank++;
    }
}
```

## 第八讲 KMP

在讲解KMP之前我们首先要知道一个概念:PMT,什么叫PMT呢？举个例子，对应字符串" abababca ",它的PMT如下表所示：

![preview](https://pic4.zhimg.com/v2-e905ece7e7d8be90afc62fe9595a9b0f_r.jpg?source=1940ef5c) 

先解释一下字符串的前缀和后缀。如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。同样可以定义后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。要注意的是，字符串本身并不是自己的后缀。

有了这个定义，就可以说明PMT中的值的意义了。**PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度**。例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。

如图 1.12 所示，要在主字符串"ababababca"中查找模式字符串"abababca"。**如果在 j 处字符不匹配，那么由于前边所说的模式字符串 PMT 的性质，主字符串中 i 指针之前的 PMT[j −1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。**这是因为主字符串在 i 位失配，也就意味着**主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的**。而我们上面也解释了，模式字符串从 0 到 j−1 ，在这个例子中就是”ababab”，其前缀集合与后缀集合的交集的最长元素为”abab”， 长度为4。所以就可以断言，**主字符串中i指针之前的 4 位一定与模式字符串的第0位至第 4 位是相同的，即长度为 4 的后缀与前缀相同**。这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持i指针不动，然后将j指针指向模式字符串的PMT[j −1]位即可。

简言之，以图中的例子来说，**在 i 处失配**，**那么主字符串和模式字符串的前边6位就是相同的**。又因为模式字符串的前6位，**它的前4位前缀和后4位后缀是相同的**，所以我们推知**主字符串i之前的4位和模式字符串开头的4位是相同的**。就是图中的灰色部分。那这部分就不用再比较了。

![img](https://pic1.zhimg.com/50/v2-03a0d005badd0b8e7116d8d07947681c_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_1440w.jpg?source=1940ef5c)

有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，**所以为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。PMT右移一位就是说我们在求最长公共前后缀的时候我们只考虑从0到j-1位置作为整体字符串。我们把新得到的这个数组称为next数组。**

举个例子，比如我们在字符串"abababca",的索引为3的位置去分别求PMT的值和next数组的值时，**求PMT我们就以"abab"作为整体字符串来看**，那么最长公共前后缀就是"ab",所以PMT的值pmt[3]为2，而**求next数组时我们这以"aba"作为整体字符串**，那么其最长公共前后缀就是"a"所以next[3]=1。

下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，**第0位的值，我们将其设成了-1**，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。

![img](https://pic4.zhimg.com/50/v2-40b4885aace7b31499da9b90b7c46ed3_hd.jpg?source=1940ef5c)

```c
//首先KMP算法主要是包括两个部分
//首先就是KMP核心部分，第二就是生成next数组

int KMP(char *t,char *p)
{
    //t表示主字符串，p表示模式字符串
    length_t=strlen(t);
    length_p=strlen(p);
    if(t==NULL || p==NULL || length_p<1|| length_t<length_p)
    {
        return -1;
    }
    int i1=0; //索引i1用于指向主字符串t
    int i2=0; //索引i2用于指向模式字符串p
    int *next = getNext(p);  //将字符串p对应的next数组进行
    while(i1<length_t&&i2<length_p) //两个指针都没到尾
	{
		if(t[i1]==p[i2])   //相等就两个继续往下走
		{
			i1++;
			i2++;
		}
		else if(i2==0)   //next[i2]==-1  就是说i2来到了首位置还不能与原字符串匹配说明 原字符串需要换一个字符
		{
			i1++;   
		}
		else
		{
			i2=next[i2];     //不等就把模式串中的i2往前退
		}
	}
	if (i2 == strlen(p)) //如果i2到尾了
       return i1 - i2;
    else 
       return -1;
}

int *getNext(char *ms)
{
    length_ms = strlen(ms);  //ms数组的长度
    int *next = (int*)malloc(sizeof(int)*length_ms);
    if(length_ms==1)
    {
        next[0]=-1;
        return next;
    }
    next[0]=-1;  //人为规定的两个值
    next[1]= 0;
    int i=2;  //next数组的位置，从下标为2开始
    int cn=0;
    while(i<length_ms)
    {
        /*我们在求解next[i]的时候，是提前知道了next[i-1]的值的，也就是说从0位置到i-2位置作为整体的字符串的最长公共前后缀的长度是已知的，假设next[i-1]=k,也就是说模式字符串从0到k-1作为前缀，从i-1-k到i-2作为后缀，这两者是相等的，那么现在就需要比较ms[k]的位置，与ms[i-1]的位置是否相等，相等那么next[i]=next[i-1]+1
 如果不相等，那么就跳到next[k]这个位置，去比较ms[next[k]]与ms[i-1]是否相等，依次类推，直到两者相等，或者跳到字符串的0位置了，相等就为1，不等就为0。继续下一个位置。
        */
        if(ms[i-1]==ms[cn])  //相等的情况
        {
            next[i++]=++cn;   
        }
        else if(cn>0)   //不等但是cn还没到头
        {
            cn=next[cn];  //往前退
        }
        else
        {
            next[i++]=0; //否则就置0，然后继续判断下一个字符去
        }
        
    }
    return next;
    
}

```

## 第九讲 Manacher(马拉车)算法

关于求解一个字符串中的最大回文子串的长度

* **经典解法：加字符**

![1617789904271](.\img\1617789904271.png)

整个算法的思路就是从字符串的首部到字符串的尾部，然后在每两个字符之间添加一个字符(**这个字符与不与原始字符串中字符互异无所谓，都可以**)。(这样做的目的就是将字符串长度变成奇数)。然后我们在从头开始遍历，在遍历的同时做一个处理，就是求以当前字符为中心的最长回文子串(就是向两边扩充),最后得到的一些值，**就是每个字符为中心的最长回文子串的长度(回文直径)**，将这个值除以2后向下取整就是原字符串中各自的最大回文子串的长度。

时间复杂度O(N^2)

* **Manacher算法**

回文半径：回文长度的一半

回文直径：整体回文串的长度

最右边界R：就是在扩充过程中右边界变大，那么就将记录R更新。

取得最远边界R时，中心点为C。

```c
/*
分为这几种情况
1、i>=R,就是说当前所求的点的下标已经超过了之前的最右边界的位置,那么这种情况就只能暴力的去扩充然后判断了
2、i<R,就是i位置还没超过最右边界，那么这种情况又分为了三种情况
   2.1 当i关于C(R所对应的中心)对称的i'点位置的最长回文串都在L(R关于C的对称)到R之间时，那么i'位置的回文半        径就是i位置的回文半径
   2.2 当i'位置的最长回文子串超过了当前以C为中心的左边界L，那么R-i就是i位置的回文半径(也好证明，看下图)
   2.3 当i'位置的最长回文子串的左边界与当前以C为中心的左边界重合，那么说明也是需要暴力去扩充
*/
//伪代码如下
int *Manacher(char *str)
{
    第一步首先处理str，将原始str --> #s#t#r;
    length_str = strlen(str);
    int *Parr = (int *)malloc(sizeof(int)*length_str);  //返回值为最终每个位置对应的回文直径
    int R=?;  //R为当前往右扩的最大边界
    int C=?;  //取得最远边界时，中心
    for(int i=0;i<length_str;i++)
    {
        if(i在R外部)
        {
            则i只能往两边暴力扩充来求最长回文串;
            R增大;
        }
        else   //(i在R内部)
        {
            if(i'回文区域彻底在L...R内)  //i'为i位置关于位置C(最大边界的中心点)的对称点
               {
                   Parr[i] = 某个O(1)的表达式;   //因为i'的所对应的Parr[i']值我们是已经知道的，
                   //而两者又是对称的，所以可以通过i'对应的值求出i对应的值
               }
            else if(i'回文区域只有一部分在L...R内，就是i'为中心的回文区域的左侧越过了L)
               {
                   Parr[i]=某个O(1)的表达式;
                   //这里是可以分析的，见下图分析
               }
            else
               {
                   //剩余情况就是i’的最长回文子串的左边界刚好与L压线，对称来说就是i的最长回文子串的右边界刚好与R压线
                   这就需要比较R往外的元素与关于i点对称的情况了;
                   如果扩失败了R不变，否则R变大
                   
               }
        }
    }
    
}
//时间复杂度为O(N)
```

![1617863957000](.\img\1617863957000.png)

​                                                   关于i'的最长回文子串有一部分在L...R外面的情况

```c
//str处理函数  str-->#s#t#r#
char *manacherstr(char *str)
{
    length_str=strlen(str);
    char *res = (char*)malloc(sizeof(char)*(2*length_str+1));
    int index=0;
    for(int i=0;i<2*length_str+1;i++)
    {
        res[i] =(i&1)==0?'#':str[index++];
    }
    return res;
}
//manacher函数
int maxLcpsLength(char *s)
{
    length_s = strlen(s);
    if(s==NULL || length_s ==0)
    {
        return 0;
    }
    char *str = manacherstr(s); //处理字符串 -->#s#t#r#
    int length_str = strlen(str);  //处理之后的字符长度
    int *pArr = (int*)malloc(sizeof(int)*length_str);  //用于接收i位置对应的回文半径值
    int C=-1; //中心
    int R=-1;  //右边界
    int max = Int_MIN_VALUE; //
    for(int i =0;i<length_str;i++)
    {
        //每个位置都求回文半径
        //如果i>=R那么不用验的区域就是1，如果在里面就是i<R,那么不用验的区域就是R-i和pArr[2*C-i](pArr[i'])两者中的较小值
        pArr[i]= R>i?min(pArr[2*C-i],R-i):1;
        
        //然后在开始尝试往外扩，我们知道只有当i>R，或者是i<R,但是pArr[i']的左边界与L压线的时候才需要往外扩，但是会有很多繁杂的ifelse，就写一个统一的往外扩的代码，这样那些不用扩的条件当他尝试去扩的时候就会失败，这样既不会影响时间复杂度也会让代码更加简洁
        while(i+pArr[i]<length_str&&i-pArr[i]>-1)
        {
            if(str[i+pArr[i]]==str[i-pArr[i]])  //就是往外扩的过程
            {
                pArr[i]++;
            }
            else
            {
                break;
            }
        }
        if(i+pArr[i]>R)  //如果某个位置的最右边界大于的当前的R，就更新R和C
        {
            R=i+pArr[i];
            C = i;
        }
        max_value = max(max_value,pArr[i]); //求一个最大值
    }
    return max_value - 1;  //处理串的回文半径-1，就是原始串的回文长度
}
```

## 第十讲 双指针

![1617868631170](.\img\1617868631170.png)

## 第十讲 单调栈

问题：给你一个数组，让你在O(N)的时间复杂度下求出i位置的左侧最近比它大的值和右侧最近比它大的值。

解法：利用一个单调栈，单调递减的栈，也就是当当前要进栈的元素比栈顶元素小的时候才将当前元素压入栈中。

否则就将栈中元素出栈，直到满足单调性的时候在将当前元素进栈。

**那么每当一个元素 出栈的时候就可以生成数据了，出栈元素出栈以后的栈顶元素就是左边最近的比自己大的元素，当前要入栈的元素就是右边最近比自己大的元素。**

leetcode类似题目  --42.接雨水

![1617875981444](.\img\1617875981444.png)

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        stack=[]  #创建一个栈保存height数组中的下标
        length_h = len(height)
        if height==None or length_h==0:
            return 0
        res=0
        for i in range(length_h):
            #如果栈顶元素所对应的值大于当前遍历所来的值，直接将元素进栈即可
            if stack==[] or height[i]<height[stack[0]]:  
                stack.insert(0,i)
            #否则就将栈中元素出栈同时计算这其中的间隔值，在将元素压入栈
            else:
                while stack!=[] and height[i]>=height[stack[0]]  :
                    cur = stack.pop(0)
                    if stack!=[]:
                        res = res + (min(height[i],height[stack[0]])-height[cur])*(i-stack[0]-1)
                stack.insert(0,i)
        return res

```

## 第十一讲  动态规划

* 题目1：

> 给定一个一维数组，有一个机器人从起点位置S，走到终点位置E，要求总步数为K，请问走的路径方法数有多少种。

```c
//解法1 ： 暴力递归
/**********
参数N就是数组的长度，一共有1~N这么多位置
参数E就是目标的位置
前两个参数都是固定参数
参数rest为剩余步数，
参数cur为当前位置
**********/
int f1(int N,int E,int rest,int cur)
{
    if(rest==0)  //无路可走，如果当前节点与目标节点相等就说明找到了 一种方法
    {
        return cur==E?1:0;
    }
    //rest>0 说明有路可以走
    if(cur==1)   //当前节点在1这个位置就说明只能向后走
    {
        return f1(N,E,rest-1,2);
    }
    if(cur==N)  //当前节点在N这个位置就说明只能向前走
    {
        return f1(N,E,rest-1,N-1);
    }
    //在中间位置时，两侧都可以走
    return f1(N,E,rest-1,cur-1) + f1(N,E,rest-1,cur+1);
}
int main()
{
    return f1(N,E,rest,cur);
}

//解法2 ：记忆化搜索
//因为我们在处理递归的时候，比如某个情况f(2,2)可以由f(3,1）来到，也可以由f(3,3)来到。那么递归函数的调过
//程就会影响性能，存在太多的重复计算，所以我们可以通过构建一个表，每次计算某个值以后就存储下来，下次需要调用的
//手就直接查表取值，这样就能节省时间复杂度。
int f2(int N,int E,int rest,int cur,int [][]dp)
{
    if(dp[rest][cur]!=-1) //不为-1就说明已经被修改过了，那么这样只需要直接查表返回即可
    {
        return dp[rest][cur];
    }
    //缓存没有命中
    if(rest==0)
    {
        dp[rest][cur]= cur==E?1:0;
    }
    else if(cur == 1)
    {
        dp[rest][cur]=f1(N,E,rest-1,2);
    }
    else if(cur==N)
    {
        dp[rest][cur]=f1(N,E,rest-1,N-1);
    }
    else
    {
        dp[rest][cur]=f1(N,E,rest-1,cur-1)+f1(N,E,rest-1,cur+1);
    }
    return dp[rest][cur];
}

int main()
{
    int dp[][] = new int[k+1][n+1];  //开辟一个(k+1)*(n+1)size的数组
    for(int i=0;i<=k;i++)
        for(int j=0;j<=n;j++)
            dp[i][j]=-1;   //初试时将所有的
    f2(n,E,rest,k,s,dp);
}
//记忆化搜索就是带一个缓存的递归，这样在递归的时候先去查表是否已经改过表的值，如果改过就直接返回，否者就去改表


//解法三：动态规划解法

```









