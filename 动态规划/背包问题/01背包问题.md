## 01背包

给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性。其中第 `i` 个物品的重量为 `wt[i]`，价值为 `val[i]`，现在让你用这个背包装物品，最多能装的价值是多少？

示例1

```
输入：
N = 3, W = 4

wt = [2, 1, 3]
val = [4, 2, 3]

输出：
6 
解释：选择前两件物品装进背包，总重量 3 小于 W ，可以获得最大价值 6。
```

动态规划的整体思路就是维持一个数组，用以记录原问题的子问题的答案，然后通过状态转移的方式逐渐由子问题求的原问题，所以核心点就在于 **确定状态** 和 **状态转移关系**，0-1背包是一个很经典的动态规划问题，我们来看看求解套路。

首先**定状态**，定义一个二维数组`  dp[N+1] [W+1]` ，**其中`dp[i][w]` 表示前`i`个物品，当背包容量为`w`时可以装入的最大价值**，举个例子，如果 `dp[3][5] = 6`，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

根据这个定义，**确定base case**就是 `dp[0][..] = dp[..][0] = 0`，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。



**状态转移**：

先重申一下刚才我们的 `dp` 数组的定义：

`dp[i][w]` 表示：对于前 `i` 个物品，当前背包的容量为 `w` 时，这种情况下可以装下的最大价值是 `dp[i][w]`。

**如果你没有把这第 `i` 个物品装入背包**，那么很显然，最大价值 `dp[i][w]` 应该等于 `dp[i-1][w]`，继承之前的结果。

**如果你把这第 `i` 个物品装入了背包**，那么 `dp[i][w]` 应该等于 `dp[i-1][w - wt[i-1]] + val[i-1]`。

首先，由于 `i` 是从 1 开始的，所以 `val` 和 `wt` 的索引是 `i-1` 时表示第 `i` 个物品的价值和重量。

而 `dp[i-1][w - wt[i-1]]` 也很好理解：你如果装了第 `i` 个物品，就要寻求剩余重量 `w - wt[i-1]` 限制下的最大价值，加上第 `i` 个物品的价值 `val[i-1]`。

综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：

```cpp
for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            dp[i-1][w],//不装当前物品
            dp[i-1][w - wt[i-1]] + val[i-1] //装当前物品
        )
return dp[N][W]
```

cpp代码

```cpp
int knapsack(int W,int N,vector<int>wt,vector<int>val)
{
   vector<vector<int>>dp(N+1,vector<int>(W+1,0));
   for(int i=1;i<=N;i++)
   {
      for(int w=1;w<=W;w++)
      {
         //当前背包容量不够装下第i个物品时
         //只能选择不装这个物体
         if(w<wt[i-1])
           dp[i][w] = dp[i-1][w];
         else
         //当背包容量够装下第i个物品时
         //此时有两个选择：装 或 不装
           dp[i][w] = max(dp[i-1][w-wt[i-1]]+val[i-1],dp[i-1][w]);
      }
   }
}
```

